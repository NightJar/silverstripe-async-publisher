<?php

namespace AndrewAndante\SilverStripe\AsyncPublisher\Extension;

use AndrewAndante\SilverStripe\AsyncPublisher\Job\AsyncDoSaveJob;
use AndrewAndante\SilverStripe\AsyncPublisher\Job\AsyncPublishJob;
use AndrewAndante\SilverStripe\AsyncPublisher\Service\AsyncPublisherService;
use SilverStripe\Control\Director;
use SilverStripe\Core\Extension;
use SilverStripe\Forms\CompositeField;
use SilverStripe\Forms\FieldList;
use SilverStripe\Forms\FormAction;
use SilverStripe\ORM\DataObject;
use SilverStripe\ORM\FieldType\DBDatetime;
use SilverStripe\Versioned\ChangeSet;
use SilverStripe\Versioned\Versioned;
use Symbiote\QueuedJobs\DataObjects\QueuedJobDescriptor;
use Symbiote\QueuedJobs\Services\QueuedJob;
use Symbiote\QueuedJobs\Services\QueuedJobService;

class AsyncPublisherExtension extends Extension
{
    public function updateCMSActions(FieldList $actions)
    {
        /** @var CompositeField $majorActions */
        $majorActions = $actions->fieldByName('MajorActions');
        if ($majorActions->fieldByName('action_publish') !== null) {
            $majorActions->removeByName('action_publish');
            $majorActions->push(
                FormAction::create('async_publish', _t(__CLASS__ . '.BUTTONASYNCPUBLISHED', 'Published'))
                    ->addExtraClass('btn-outline-primary font-icon-tick')
                    ->setAttribute('data-btn-alternate-add', 'btn-primary font-icon-rocket')
                    ->setAttribute('data-btn-alternate-remove', 'btn-outline-primary font-icon-tick')
                    ->setUseButtonTag(true)
                    ->setAttribute('data-text-alternate', _t(__CLASS__ . '.BUTTONASYNCSAVEPUBLISH', 'Queue Publish'))
            );
        }
    }

    public function publishSingle()
    {
        $publishJob = AsyncPublishJob::create($this->owner, Versioned::LIVE, false);
        QueuedJobService::singleton()->queueJob($publishJob);
    }

    public function publishRecursive()
    {
        $publishJob = AsyncPublishJob::create($this->owner, Versioned::LIVE, true);
        QueuedJobService::singleton()->queueJob($publishJob);
    }

    public function doPublishSingle()
    {
        $owner = $this->owner;
        // get the last published version
        $original = null;
        if ($owner->isPublished()) {
            $original = Versioned::get_by_stage($owner->baseClass(), Versioned::LIVE)
                ->byID($owner->ID);
        }

        // Publish it
        $owner->invokeWithExtensions('onBeforePublish', $original);
        $owner->writeToStage(Versioned::LIVE);
        $owner->invokeWithExtensions('onAfterPublish', $original);
        return true;
    }

    public function doPublishRecursive()
    {
        $now = DBDatetime::now()->Rfc2822();

        return DBDatetime::withFixedNow($now, function () {
            /** @var DataObject|Versioned $owner */
            $owner = $this->owner;

            // get the last published version
            $original = null;
            if ($owner->hasExtension(Versioned::class) && $owner->isPublished()) {
                $original = Versioned::get_by_stage($owner->baseClass(), Versioned::LIVE)
                    ->byID($owner->ID);
            }

            $owner->invokeWithExtensions('onBeforePublishRecursive', $original);

            // Create a new changeset for this item and publish it
            $changeset = ChangeSet::create();
            $changeset->IsInferred = true;
            $changeset->Name = _t(
                __CLASS__ . '.INFERRED_TITLE',
                "Generated by publish of '{title}' at {created}",
                [
                    'title' => $owner->Title,
                    'created' => DBDatetime::now()->Nice()
                ]
            );

            $changeset->write();
            $changeset->addObject($owner);

            $result = $changeset->publish(true);
            if ($result) {
                $owner->invokeWithExtensions('onAfterPublishRecursive', $original);
            }

            return $result;
        });
    }

    public function canEdit($member = null)
    {
        if (!Director::is_cli() && $this->pendingJobsExist([AsyncDoSaveJob::class])) {
            return false;
        }

        return null;
    }

    public function canPublish($member = null): ?bool
    {
        if (!Director::is_cli() && $this->pendingJobsExist([AsyncDoSaveJob::class, AsyncPublishJob::class])) {
            return false;
        }

        return null;
    }

    /**
     * @param string[] $classes
     * @return bool
     */
    private function pendingJobsExist(array $classes): bool
    {
        return QueuedJobDescriptor::get()->filter([
            'Implementation' => $classes,
            'Signature' => AsyncPublisherService::generateSignature($this->owner),
            'JobStatus' => [
                QueuedJob::STATUS_NEW,
                QueuedJob::STATUS_INIT,
                QueuedJob::STATUS_WAIT,
            ]
        ])->exists();
    }
}
